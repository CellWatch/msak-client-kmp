package edu.gatech.cc.cellwatch.msak.shared

import io.ktor.http.Url
import kotlin.random.Random

/**
 * Builds a complete [Server] URL map for both latency and throughput.
 *
 * Goals:
 *  - Single entry point to construct a usable Server for local/dev or demo use.
 *  - No hidden URL "massaging" later — the map contains fully-formed absolute URLs.
 *  - Tolerant logical keys: both cleartext and TLS logical keys are populated.
 *
 * Two construction modes:
 *
 * 1) Local/dev synthesis via [buildServer]:
 *    ```
 *    val srv = ServerFactory.buildServer(
 *        host = "127.0.0.1",
 *        port = 8080,
 *        useTls = false,                // true -> https/wss with default 443 if port <= 0
 *        includeLatency = true,
 *        includeThroughput = true,
 *        measurementId = "your-mid"     // optional; autogenerated if null
 *    )
 *    ```
 *
 *    This emits (at minimum) the following logical keys:
 *      - "http:///latency/v1/authorize"
 *      - "http:///latency/v1/result"
 *      - "ws:///throughput/v1/download"
 *      - "ws:///throughput/v1/upload"
 *    And their TLS aliases ("https:///...", "wss:///...") pointing to the same absolute URLs.
 *
 * 2) Absolute URLs via [buildFromAbsolute]:
 *    Use this when you have URLs from Locate. We DO NOT change schemes or ports.
 *    Example:
 *    ```
 *    val srv = ServerFactory.buildFromAbsolute(
 *        latencyAuthorize = "https://host/latency/v1/authorize?mid=...",
 *        latencyResult    = "https://host/latency/v1/result?mid=...",
 *        tputDownload     = "wss://host/throughput/v1/download?access_token=...",
 *        tputUpload       = "wss://host/throughput/v1/upload?access_token=..."
 *    )
 *    ```
 *
 * ⚠️ IMPORTANT:
 * - Do not mix "local synthesis" with "absolute" in the same call; pick one constructor.
 * - If you pass URLs from Locate, they may already include query params (mid, access_token). We leave them verbatim.
 */
object ServerFactory {

    // Logical keys expected by Server URL resolvers
    private const val LATENCY_AUTHORIZE_KEY        = "http:///latency/v1/authorize"
    private const val LATENCY_RESULT_KEY           = "http:///latency/v1/result"
    private const val THROUGHPUT_DOWNLOAD_KEY      = "ws:///throughput/v1/download"
    private const val THROUGHPUT_UPLOAD_KEY        = "ws:///throughput/v1/upload"

    // TLS aliases (logical keys some callers may use)
    private const val LATENCY_AUTHORIZE_KEY_TLS    = "https:///latency/v1/authorize"
    private const val LATENCY_RESULT_KEY_TLS       = "https:///latency/v1/result"
    private const val THROUGHPUT_DOWNLOAD_KEY_TLS  = "wss:///throughput/v1/download"
    private const val THROUGHPUT_UPLOAD_KEY_TLS    = "wss:///throughput/v1/upload"

    // Default paths
    private const val LAT_PATH_PREFIX = "/latency/v1"
    private const val TPUT_PATH_PREFIX = "/throughput/v1"

    // Ensures path prefixes are well-formed (leading slash, no trailing slash)
    private fun normPrefix(p: String): String {
        var s = p.trim()
        if (!s.startsWith("/")) s = "/$s"
        if (s.endsWith("/")) s = s.dropLast(1)
        return s
    }

    // Appends a query parameter, handling existing queries
    private fun appendQuery(url: String, name: String, value: String): String =
        if (url.indexOf('?') >= 0) "$url&$name=$value" else "$url?$name=$value"

    // ----------------------------
    // Local/dev synthesis
    // ----------------------------


    /**
     * Construct a full [Server] for local/dev usage from host/port knobs.
     * Populates both latency and throughput endpoints unless disabled.
     *
     * @param host e.g., "127.0.0.1"
     * @param port HTTP and WS port (use same). If &lt;= 0, defaults to 443 for TLS, else 80.
     * @param useTls whether to use https/wss
     * @param includeLatency include latency endpoints
     * @param includeThroughput include throughput endpoints
     * @param measurementId optional MID; if null, a v4 UUID is generated
     */
    fun buildServer(
        host: String,
        port: Int,
        useTls: Boolean,
        includeLatency: Boolean = true,
        includeThroughput: Boolean = true,
        measurementId: String? = null,
        latencyPathPrefix: String = LAT_PATH_PREFIX,
        throughputPathPrefix: String = TPUT_PATH_PREFIX,
    ): Server {
        val mid = measurementId ?: newMeasurementId()
        val schemeHttp = if (useTls) "https" else "http"
        val schemeWs = if (useTls) "wss" else "ws"
        val p = when {
            port > 0 -> port
            useTls -> 443
            else -> 80
        }
        val httpBase = "$schemeHttp://$host:$p"
        val wsBase = "$schemeWs://$host:$p"

        val latPrefix = normPrefix(latencyPathPrefix)
        val tputPrefix = normPrefix(throughputPathPrefix)

        val urls = mutableMapOf<String, String>()

        if (includeLatency) {
            val auth = appendQuery("$httpBase$latPrefix/authorize", "mid", mid)
            val res  = appendQuery("$httpBase$latPrefix/result", "mid", mid)
            urls[LATENCY_AUTHORIZE_KEY] = auth
            urls[LATENCY_RESULT_KEY] = res
            // TLS logical aliases point to the same absolute URLs (harmless + tolerant).
            urls[LATENCY_AUTHORIZE_KEY_TLS] = auth
            urls[LATENCY_RESULT_KEY_TLS] = res
        }

        if (includeThroughput) {
            val dl = appendQuery("$wsBase$tputPrefix/download", "mid", mid)
            val ul = appendQuery("$wsBase$tputPrefix/upload", "mid", mid)
            urls[THROUGHPUT_DOWNLOAD_KEY] = dl
            urls[THROUGHPUT_UPLOAD_KEY] = ul
            // TLS logical aliases point to the same absolute URLs (harmless + tolerant).
            urls[THROUGHPUT_DOWNLOAD_KEY_TLS] = dl
            urls[THROUGHPUT_UPLOAD_KEY_TLS] = ul
        }

        // Sanity check: ensure all URLs are parseable absolute URLs
        urls.forEach { (k, v) ->
            try {
                Url(v) // validate parseable absolute URL
            } catch (t: Throwable) {
                // If Log.e is available in shared, log here:
                // Log.e("ServerFactory", "Malformed URL for key '$k': '$v' — ${t.message ?: t::class.simpleName}")
            }
        }

        return Server(machine = host, location = null, urls = urls)
    }

    // ----------------------------
    // Absolute URLs (e.g., from Locate)
    // ----------------------------

    /**
     * Build a [Server] from absolute URLs you already have (e.g., from Locate).
     * Any parameter that is null is simply omitted from the map.
     * We DO NOT alter schemes, ports, or query parameters.
     *
     * For tolerance, we also populate TLS/non‑TLS logical aliases to the same value
     * so downstream lookups succeed regardless of which logical key they request.
     */
    fun buildFromAbsolute(
        latencyAuthorize: String? = null,
        latencyResult: String? = null,
        tputDownload: String? = null,
        tputUpload: String? = null
    ): Server {
        val host = listOfNotNull(latencyAuthorize, latencyResult, tputDownload, tputUpload)
            .firstNotNullOfOrNull { safeHost(it) } ?: ""

        val urls = mutableMapOf<String, String>()

        fun putLatency(authorize: Boolean, url: String) {
            if (authorize) {
                urls[LATENCY_AUTHORIZE_KEY] = url
                urls[LATENCY_AUTHORIZE_KEY_TLS] = url
            } else {
                urls[LATENCY_RESULT_KEY] = url
                urls[LATENCY_RESULT_KEY_TLS] = url
            }
        }

        fun putThroughput(download: Boolean, url: String) {
            if (download) {
                urls[THROUGHPUT_DOWNLOAD_KEY] = url
                urls[THROUGHPUT_DOWNLOAD_KEY_TLS] = url
            } else {
                urls[THROUGHPUT_UPLOAD_KEY] = url
                urls[THROUGHPUT_UPLOAD_KEY_TLS] = url
            }
        }

        latencyAuthorize?.let { putLatency(authorize = true, url = it) }
        latencyResult?.let { putLatency(authorize = false, url = it) }
        tputDownload?.let { putThroughput(download = true, url = it) }
        tputUpload?.let { putThroughput(download = false, url = it) }

        if (urls.isEmpty()) {
            throw IllegalArgumentException("buildFromAbsolute: no URLs provided")
        }

        return Server(machine = host, location = null, urls = urls)
    }

    // ----------------------------
    // Helpers
    // ----------------------------

    private fun newMeasurementId(): String {
        val bytes = ByteArray(16)
        Random.nextBytes(bytes)
        // version 4 (random) & RFC 4122 variant
        bytes[6] = (bytes[6].toInt() and 0x0F or 0x40).toByte()
        bytes[8] = (bytes[8].toInt() and 0x3F or 0x80).toByte()
        fun Byte.toHex() = (toInt() and 0xFF).toString(16).padStart(2, '0')
        val hex = bytes.joinToString("") { it.toHex() }
        return buildString(36) {
            append(hex, 0, 8); append('-')
            append(hex, 8, 12); append('-')
            append(hex, 12, 16); append('-')
            append(hex, 16, 20); append('-')
            append(hex, 20, 32)
        }
    }

    // Extract host from an absolute URL without throwing; used to populate Server.machine for display/logging.
    private fun safeHost(absoluteUrl: String): String? = try {
        Url(absoluteUrl).host
    } catch (_: Throwable) {
        null
    }
}